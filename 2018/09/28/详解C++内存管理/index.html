<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="原文 内存管理是C++最令人切齿痛恨的问题，也是C++最有争议的问题，C++高手从中获得了更好的性能，更大的自由，C++菜鸟的收获则是一遍一遍的检查代码和对C++的痛恨，但内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生，因此要想成为C++高手，内存管理一关是必须要过的，除非放弃C++，转到Java或者.NET，他们的内存管理基本是自动的，当然你也放弃了自由和对内存的支配权，还放">
<meta property="og:type" content="article">
<meta property="og:title" content="C++内存管理（超长，例子很详细，排版很好）">
<meta property="og:url" content="https://xiaojun-cd.github.io/2018/09/28/详解C++内存管理/index.html">
<meta property="og:site_name" content="自由的心">
<meta property="og:description" content="原文 内存管理是C++最令人切齿痛恨的问题，也是C++最有争议的问题，C++高手从中获得了更好的性能，更大的自由，C++菜鸟的收获则是一遍一遍的检查代码和对C++的痛恨，但内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生，因此要想成为C++高手，内存管理一关是必须要过的，除非放弃C++，转到Java或者.NET，他们的内存管理基本是自动的，当然你也放弃了自由和对内存的支配权，还放">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-09-28T00:10:48.384Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++内存管理（超长，例子很详细，排版很好）">
<meta name="twitter:description" content="原文 内存管理是C++最令人切齿痛恨的问题，也是C++最有争议的问题，C++高手从中获得了更好的性能，更大的自由，C++菜鸟的收获则是一遍一遍的检查代码和对C++的痛恨，但内存管理在C++中无处不在，内存泄漏几乎在每个C++程序中都会发生，因此要想成为C++高手，内存管理一关是必须要过的，除非放弃C++，转到Java或者.NET，他们的内存管理基本是自动的，当然你也放弃了自由和对内存的支配权，还放">






  <link rel="canonical" href="https://xiaojun-cd.github.io/2018/09/28/详解C++内存管理/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>C++内存管理（超长，例子很详细，排版很好） | 自由的心</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">自由的心</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">要么旅行，要么读书，身体和灵魂，必须有一个在路上</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xiaojun-cd.github.io/2018/09/28/详解C++内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="XiaoJun">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="自由的心">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C++内存管理（超长，例子很详细，排版很好）
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-28 08:10:48" itemprop="dateCreated datePublished" datetime="2018-09-28T08:10:48+08:00">2018-09-28</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="https://blog.csdn.net/caogenwangbaoqiang/article/details/79788368" target="_blank" rel="noopener">原文</a></p>
<p>内存管理是C++最令人切齿痛恨的问题，也是C++最有争议的问题，C++高手从中获得了更好的性能，<br>更大的自由，C++菜鸟的收获则是一遍一遍的检查代码和对C++的痛恨，但内存管理在C++中无处不<br>在，内存泄漏几乎在每个C++程序中都会发生，因此要想成为C++高手，内存管理一关是必须要过的，<br>除非放弃C++，转到Java或者.NET，他们的内存管理基本是自动的，当然你也放弃了自由和对内存<br>的支配权，还放弃了C++超绝的性能。本期专题将从内存管理、内存泄漏、内存回收这三个方面来<br>探讨C++内存管理问题。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>伟大的Bill Gates 曾经失言：</p>
<blockquote>
<p>640K ought to be enough for everybody — Bill Gates 1981<br>程序员们经常编写内存管理程序，往往提心吊胆。如果不想触雷，唯一的解决办法就是发现所有<br>潜伏的地雷并且排除它们，躲是躲不了的。本文的内容比一般教科书的要深入得多，读者需细心<br>阅读，做到真正地通晓内存管理。</p>
</blockquote>
<h2 id="C-内存管理详解"><a href="#C-内存管理详解" class="headerlink" title="C++内存管理详解"></a>C++内存管理详解</h2><h3 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h3><h4 id="分配方式简介"><a href="#分配方式简介" class="headerlink" title="分配方式简介"></a>分配方式简介</h4><p>在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。</p>
<p>栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元<br>自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>
<p>堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个<br>new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</p>
<p>自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自<br>己的生命的。</p>
<p>全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分<br>为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。</p>
<p>常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。</p>
<h4 id="明确区分堆与栈"><a href="#明确区分堆与栈" class="headerlink" title="明确区分堆与栈"></a>明确区分堆与栈</h4><p>在bbs上，堆与栈的区分问题，似乎是一个永恒的话题，由此可见，初学者对此往往是混淆不清的，所以我决定拿他第一个开刀。</p>
<p>首先，我们举一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void f() &#123; int* p=new int[5]; &#125;</span><br></pre></td></tr></table></figure></p>
<p>这条短短的一句话就包含了堆与栈，看到new，我们首先就应该想到，我们分配了一块堆内存，那么<br>指针p呢？他分配的是一块栈内存，所以这句话的意思就是：在栈内存中存放了一个指向一块堆内存<br>的指针p。在程序会先确定在堆中分配内存的大小，然后调用operator new分配内存，然后返回这块<br>内存的首地址，放入栈中，他在VC6下的汇编代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">00401028 push 14h</span><br><span class="line"></span><br><span class="line">0040102A call operator new (00401060)</span><br><span class="line"></span><br><span class="line">0040102F add esp,4</span><br><span class="line"></span><br><span class="line">00401032 mov dword ptr [ebp-8],eax</span><br><span class="line"></span><br><span class="line">00401035 mov eax,dword ptr [ebp-8]</span><br><span class="line"></span><br><span class="line">00401038 mov dword ptr [ebp-4],eax</span><br></pre></td></tr></table></figure></p>
<p>这里，我们为了简单并没有释放内存，那么该怎么去释放呢？是delete p么？澳，错了，应该是delete []p，<br>这是为了告诉编译器：我删除的是一个数组，VC6就会根据相应的Cookie信息去进行释放内存的工作。</p>
<h4 id="堆和栈究竟有什么区别？"><a href="#堆和栈究竟有什么区别？" class="headerlink" title="堆和栈究竟有什么区别？"></a>堆和栈究竟有什么区别？</h4><p>好了，我们回到我们的主题：堆和栈究竟有什么区别？<br>主要的区别由以下几点：</p>
<p>　　1、管理方式不同；</p>
<p>　　2、空间大小不同；</p>
<p>　　3、能否产生碎片不同；</p>
<p>　　4、生长方向不同；</p>
<p>　　5、分配方式不同；</p>
<p>　　6、分配效率不同；</p>
<p>管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。</p>
<p>　　空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的，例如，在VC6下面，默认的栈空间大小是1M（好像是，记不清楚了）。当然，我们可以修改：</p>
<p>　　打开工程，依次操作菜单如下：Project-&gt;Setting-&gt;Link，在Category 中选中Output，然后在Reserve中设定堆栈的最大值和commit。</p>
<p>　　注意：reserve最小值为4Byte；commit是保留在虚拟内存的页文件里面，它设置的较大会使栈开辟较大的值，可能增加内存的开销和启动时间。</p>
<p>　　碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出，详细的可以参考数据结构，这里我们就不再一一讨论了。</p>
<p>　　生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</p>
<p>　　分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</p>
<p>　　分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法（具体的算法可以参考数据结构/操作系统）在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间（可能是由于内存碎片太多），就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。</p>
<p>　　从这里我们可以看到，堆和栈相比，由于大量new/delete的使用，容易造成大量的内存碎片；由于没有专门的系统支持，效率很低；由于可能引发用户态和核心态的切换，内存的申请，代价变得更加昂贵。所以栈在程序中是应用最广泛的，就算是函数的调用也利用栈去完成，函数调用过程中的参数，返回地址，EBP和局部变量都采用栈的方式存放。所以，我们推荐大家尽量用栈，而不是用堆。</p>
<p>　　虽然栈有如此众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，还是用堆好一些。</p>
<p>无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是程序崩溃，要么是摧毁程序的堆、栈结构，产生以想不到的结果,就算是在你的程序运行过程中，没有发生上面的问题，你还是要小心，说不定什么时候就崩掉，那时候debug可是相当困难的：）</p>
<h3 id="控制C-的内存分配"><a href="#控制C-的内存分配" class="headerlink" title="控制C++的内存分配"></a>控制C++的内存分配</h3><p>在嵌入式系统中使用C++的一个常见问题是内存分配，即对new 和 delete 操作符的失控。</p>
<p>　　具有讽刺意味的是，问题的根源却是C++对内存的管理非常的容易而且安全。具体地说，当一个对象被消除时，它的析构函数能够安全的释放所分配的内存。</p>
<p>　　这当然是个好事情，但是这种使用的简单性使得程序员们过度使用new 和 delete，而不注意在嵌入式C++环境中的因果关系。并且，在嵌入式系统中，由于内存的限制，频繁的动态分配不定大小的内存会引起很大的问题以及堆破碎的风险。</p>
<p>　　作为忠告，保守的使用内存分配是嵌入式环境中的第一原则。</p>
<p>　　但当你必须要使用new 和delete时，你不得不控制C++中的内存分配。你需要用一个全局的new 和delete来代替系统的内存分配符，并且一个类一个类的重载new 和delete。</p>
<p>　　一个防止堆破碎的通用方法是从不同固定大小的内存持中分配不同类型的对象。对每个类重载new 和delete就提供了这样的控制。</p>
<h4 id="重载全局的new和delete操作符"><a href="#重载全局的new和delete操作符" class="headerlink" title="重载全局的new和delete操作符"></a>重载全局的new和delete操作符</h4><p>可以很容易地重载new 和 delete 操作符，如下所示:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void * operator new(size_t size)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">void *p = malloc(size);</span><br><span class="line"></span><br><span class="line">return (p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void operator delete(void *p);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">free(p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码可以代替默认的操作符来满足内存分配的请求。出于解释C++的目的，我们也可以直接调用malloc() 和free()。</p>
<p>也可以对单个类的new 和 delete 操作符重载。这是你能灵活的控制对象的内存分配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">lass TestClass &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">void * operator new(size_t size);</span><br><span class="line"></span><br><span class="line">void operator delete(void *p);</span><br><span class="line"></span><br><span class="line">// .. other members here ...</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void *TestClass::operator new(size_t size)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">void *p = malloc(size); // Replace this with alternative allocator</span><br><span class="line"></span><br><span class="line">return (p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestClass::operator delete(void *p)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">free(p); // Replace this with alternative de-allocator</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有TestClass 对象的内存分配都采用这段代码。更进一步，任何从TestClass 继承的类也都采用这一方式，除非它自己也重载<br>了new 和 delete 操作符。通过重载new 和 delete 操作符的方法，你可以自由地采用不同的分配策略，从不同的内存池中分配不同的类对象。</p>
<h4 id="为单个的类重载-new-和delete"><a href="#为单个的类重载-new-和delete" class="headerlink" title="为单个的类重载 new[ ]和delete[ ]"></a>为单个的类重载 new[ ]和delete[ ]</h4><p>必须小心对象数组的分配。你可能希望调用到被你重载过的new 和 delete 操作符，但并不如此。内存的请求被定向到全局的new[ ]和delete[ ]<br>操作符，而这些内存来自于系统堆。</p>
<p>C++将对象数组的内存分配作为一个单独的操作，而不同于单个对象的内存分配。为了改变这种方式，你同样需要重载new[ ] 和 delete[ ]操作符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class TestClass &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">void * operator new[ ](size_t size);</span><br><span class="line"></span><br><span class="line">void operator delete[ ](void *p);</span><br><span class="line"></span><br><span class="line">// .. other members here ..</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void *TestClass::operator new[ ](size_t size)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">void *p = malloc(size);</span><br><span class="line"></span><br><span class="line">return (p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TestClass::operator delete[ ](void *p)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">free(p);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">TestClass *p = new TestClass[10];</span><br><span class="line"></span><br><span class="line">// ... etc ...</span><br><span class="line"></span><br><span class="line">delete[ ] p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="常见的内存错误及其对策"><a href="#常见的内存错误及其对策" class="headerlink" title="常见的内存错误及其对策"></a>常见的内存错误及其对策</h3><p>发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。而这些错误大多没有明显的症状，<br>时隐时现，增加了改错的难度。有时用户怒气冲冲地把你找来，程序却没有发生任何问题，你一走，错误又发作了。 常见的内存错误及其对策如下：</p>
<p>　　* 内存分配未成功，却使用了它。</p>
<p>　　编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果指针p是函数的参数，那么在函数的入口处用assert(p!=NULL)进行</p>
<p>　　检查。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。</p>
<p>　　* 内存分配虽然成功，但是尚未初始化就引用它。</p>
<p>　　犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值错误（例如数组）。 内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</p>
<p>　　* 内存分配成功并且已经初始化，但操作越过了内存的边界。</p>
<p>　　例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞错，导致数组操作越界。</p>
<p>　　* 忘记了释放内存，造成内存泄露。</p>
<p>　　含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。</p>
<p>　　动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误（new/delete同理）。</p>
<ul>
<li>释放了内存却继续使用它。</li>
</ul>
<p>有三种情况：</p>
<p>　　（1）程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新设计数据结构，从根本上解决对象管理的混乱局面。</p>
<p>　　（2）函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函数体结束时被自动销毁。</p>
<p>　　（3）使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。</p>
<p>　　【规则1】用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存。</p>
<p>　　【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。</p>
<p>　　【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。</p>
<p>　　【规则4】动态内存的申请与释放必须配对，防止内存泄漏。</p>
<p>　　【规则5】用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。</p>
<h3 id="指针与数组的对比"><a href="#指针与数组的对比" class="headerlink" title="指针与数组的对比"></a>指针与数组的对比</h3><p>C++/C程序中，指针和数组在不少地方可以相互替换着用，让人产生一种错觉，以为两者是等价的。</p>
<p>　　数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。数组名对应着（而不是指向）一块内存，其地址与容量在生命期内保持不变，只有数组的内容可以改变。</p>
<p>　　指针可以随时指向任意类型的内存块，它的特征是“可变”，所以我们常用指针来操作动态内存。指针远比数组灵活，但也更危险。</p>
<p>　　下面以字符串为例比较指针与数组的特性。</p>
<h4 id="修改内容"><a href="#修改内容" class="headerlink" title="修改内容"></a>修改内容</h4><p>下面示例中，字符数组a的容量是6个字符，其内容为hello。a的内容可以改变，如a[0]= ‘X’。指针p指向常量字符串“world”（位于静态存储区，内容为world），<br>常量字符串的内容是不可以被修改的。从语法上看，编译器并不觉得语句p[0]= ‘X’有什么不妥，但是该语句企图修改常量字符串的内容而导致运行错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">char a[] = “hello”;</span><br><span class="line"></span><br><span class="line">a[0] = ‘X’;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">char *p = “world”; // 注意p指向常量字符串</span><br><span class="line"></span><br><span class="line">p[0] = ‘X’; // 编译器不能发现该错误</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<h4 id="内容复制与比较"><a href="#内容复制与比较" class="headerlink" title="内容复制与比较"></a>内容复制与比较</h4><p>不能对数组名进行直接复制与比较。若想把数组a的内容复制给数组b，不能用语句 b = a ，否则将产生编译错误。应该用标准库函数strcpy进行复制。<br>同理，比较b和a的内容是否相同，不能用if(b==a) 来判断，应该用标准库函数strcmp进行比较。</p>
<p>语句p = a 并不能把a的内容复制指针p，而是把a的地址赋给了p。要想复制a的内容，可以先用库函数malloc为p申请一块容量为strlen(a)+1个字符的<br>内存，再用strcpy进行字符串复制。同理，语句if(p==a) 比较的不是内容而是地址，应该用库函数strcmp来比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 数组…</span><br><span class="line"></span><br><span class="line">char a[] = &quot;hello&quot;;</span><br><span class="line"></span><br><span class="line">char b[10];</span><br><span class="line"></span><br><span class="line">strcpy(b, a); // 不能用 b = a;</span><br><span class="line"></span><br><span class="line">if(strcmp(b, a) == 0) // 不能用 if (b == a)</span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">// 指针…</span><br><span class="line"></span><br><span class="line">int len = strlen(a);</span><br><span class="line"></span><br><span class="line">char *p = (char *)malloc(sizeof(char)*(len+1));</span><br><span class="line"></span><br><span class="line">strcpy(p,a); // 不要用 p = a;</span><br><span class="line"></span><br><span class="line">if(strcmp(p, a) == 0) // 不要用 if (p == a)</span><br><span class="line"></span><br><span class="line">…</span><br></pre></td></tr></table></figure>
<h4 id="计算内存容量"><a href="#计算内存容量" class="headerlink" title="计算内存容量"></a>计算内存容量</h4><p>用运算符sizeof可以计算出数组的容量（字节数）。如下示例中，sizeof(a)的值是12（注意别忘了’’）。指针p指向a，但是sizeof(p)的值却是4。这是因为sizeof(p)<br>得到的是一个指针变量的字节数，相当于sizeof(char*)，而不是p所指的内存容量。C++/C语言没有办法知道指针所指的内存容量，除非在申请内存时记住它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">char a[] = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line">char *p = a;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 12字节</span><br><span class="line"></span><br><span class="line">cout&lt;&lt; sizeof(p) &lt;&lt; endl; // 4字节</span><br></pre></td></tr></table></figure>
<p>注意当数组作为函数的参数进行传递时，该数组自动退化为同类型的指针。如下示例中，不论数组a的容量是多少，sizeof(a)始终等于sizeof(char *)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void Func(char a[100])</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　cout&lt;&lt; sizeof(a) &lt;&lt; endl; // 4字节而不是100字节</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="指针参数是如何传递内存的？"><a href="#指针参数是如何传递内存的？" class="headerlink" title="指针参数是如何传递内存的？"></a>指针参数是如何传递内存的？</h3><p>如果函数的参数是一个指针，不要指望用该指针去申请动态内存。如下示例中，Test函数的语句GetMemory(str, 200)并没有使str获得期望的内存，str依旧是NULL，为什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void GetMemory(char *p, int num)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　p = (char *)malloc(sizeof(char) * num);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　char *str = NULL;</span><br><span class="line"></span><br><span class="line">　GetMemory(str, 100); // str 仍然为 NULL</span><br><span class="line"></span><br><span class="line">　strcpy(str, &quot;hello&quot;); // 运行错误</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>毛病出在函数GetMemory中。编译器总是要为函数的每个参数制作临时副本，指针参数p的副本是 _p，编译器使 _p = p。如果函数体内的程序修改了_p的内容，<br>就导致参数p的内容作相应的修改。这就是指针可以用作输出参数的原因。在本例中，_p申请了新的内存，只是把_p所指的内存地址改变了，但是p丝毫未变。所<br>以函数GetMemory并不能输出任何东西。事实上，每执行一次GetMemory就会泄露一块内存，因为没有用free释放内存。</p>
<p>如果非得要用指针参数去申请内存，那么应该改用“指向指针的指针”，见示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void GetMemory2(char **p, int num)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　*p = (char *)malloc(sizeof(char) * num);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test2(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　char *str = NULL;</span><br><span class="line"></span><br><span class="line">　GetMemory2(&amp;str, 100); // 注意参数是 &amp;str，而不是str</span><br><span class="line"></span><br><span class="line">　strcpy(str, &quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">　cout&lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">　free(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于“指向指针的指针”这个概念不容易理解，我们可以用函数返回值来传递动态内存。这种方法更加简单，见示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">char *GetMemory3(int num)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　char *p = (char *)malloc(sizeof(char) * num);</span><br><span class="line"></span><br><span class="line">　return p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test3(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　char *str = NULL;</span><br><span class="line"></span><br><span class="line">　str = GetMemory3(100);</span><br><span class="line"></span><br><span class="line">　strcpy(str, &quot;hello&quot;);</span><br><span class="line"></span><br><span class="line">　cout&lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">　free(str);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用函数返回值来传递动态内存这种方法虽然好用，但是常常有人把return语句用错了。这里强调不要用return语句返回指向“栈内存”的指针，<br>因为该内存在函数结束时自动消亡，见示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">char *GetString(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　char p[] = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line">　return p; // 编译器将提出警告</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test4(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　char *str = NULL;</span><br><span class="line"></span><br><span class="line">　str = GetString(); // str 的内容是垃圾</span><br><span class="line"></span><br><span class="line">　cout&lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用调试器逐步跟踪Test4，发现执行str = GetString语句后str不再是NULL指针，但是str的内容不是“hello world”而是垃圾。</p>
<p>如果把上述示例改写成如下示例，会怎么样？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">char *GetString2(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　char *p = &quot;hello world&quot;;</span><br><span class="line"></span><br><span class="line">　return p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Test5(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　char *str = NULL;</span><br><span class="line"></span><br><span class="line">　str = GetString2();</span><br><span class="line"></span><br><span class="line">　cout&lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数Test5运行虽然不会出错，但是函数GetString2的设计概念却是错误的。因为GetString2内的“hello world”是常量字符串，位于<br>静态存储区，它在程序生命期内恒定不变。无论什么时候调用GetString2，它返回的始终是同一个“只读”的内存块。</p>
<h3 id="杜绝“野指针”"><a href="#杜绝“野指针”" class="headerlink" title="杜绝“野指针”"></a>杜绝“野指针”</h3><p>“野指针”不是NULL指针，是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。 “野指针”的成因主要有两种：</p>
<p>（1）指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，<br>要么将指针设置为NULL，要么让它指向合法的内存。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char *p = NULL;</span><br><span class="line"></span><br><span class="line">char *str = (char *) malloc(100);</span><br></pre></td></tr></table></figure></p>
<p>（2）指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。</p>
<p>（3）指针操作超越了变量的作用域范围。这种情况让人防不胜防，示例程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　public:</span><br><span class="line"></span><br><span class="line">　　void Func(void)&#123; cout &lt;&lt; “Func of class A” &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Test(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　A *p;</span><br><span class="line"></span><br><span class="line">　&#123;</span><br><span class="line"></span><br><span class="line">　　A a;</span><br><span class="line"></span><br><span class="line">　　p = &amp;a; // 注意 a 的生命期</span><br><span class="line"></span><br><span class="line">　&#125;</span><br><span class="line"></span><br><span class="line">　p-&gt;Func(); // p是“野指针”</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数Test在执行语句p-&gt;Func()时，对象a已经消失，而p是指向a的，所以p就成了“野指针”。但奇怪的是我运行这个程序时居然没有出错，这可能与编译器有关。</p>
<h3 id="有了malloc-free为什么还要new-delete？"><a href="#有了malloc-free为什么还要new-delete？" class="headerlink" title="有了malloc/free为什么还要new/delete？"></a>有了malloc/free为什么还要new/delete？</h3><p>malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。</p>
<p>对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。<br>由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。</p>
<p>因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函数。<br>我们先看一看malloc/free和new/delete如何实现对象的动态内存管理，见示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class Obj</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　public :</span><br><span class="line"></span><br><span class="line">　　Obj(void)&#123; cout &lt;&lt; “Initialization” &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">　　~Obj(void)&#123; cout &lt;&lt; “Destroy” &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">　　void Initialize(void)&#123; cout &lt;&lt; “Initialization” &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">　　void Destroy(void)&#123; cout &lt;&lt; “Destroy” &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void UseMallocFree(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　Obj *a = (obj *)malloc(sizeof(obj)); // 申请动态内存</span><br><span class="line"></span><br><span class="line">　a-&gt;Initialize(); // 初始化</span><br><span class="line"></span><br><span class="line">　//…</span><br><span class="line"></span><br><span class="line">　a-&gt;Destroy(); // 清除工作</span><br><span class="line"></span><br><span class="line">　free(a); // 释放内存</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void UseNewDelete(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　Obj *a = new Obj; // 申请动态内存并且初始化</span><br><span class="line"></span><br><span class="line">　//…</span><br><span class="line"></span><br><span class="line">　delete a; // 清除并且释放内存</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类Obj的函数Initialize模拟了构造函数的功能，函数Destroy模拟了析构函数的功能。函数UseMallocFree中，由于malloc/free不能执行构造函数与析构函数，<br>必须调用成员函数Initialize和Destroy来完成初始化与清除工作。函数UseNewDelete则简单得多。</p>
<p>所以我们不要企图用malloc/free来完成动态对象的内存管理，应该用new/delete。由于内部数据类型的“对象”没有构造与析构的过程，对它们而言malloc/free和new/delete是等价的。</p>
<p>既然new/delete的功能完全覆盖了malloc/free，为什么C++不把malloc/free淘汰出局呢？这是因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。</p>
<p>如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，结果也会导致程序出错，<br>但是该程序的可读性很差。所以new/delete必须配对使用，malloc/free也一样。</p>
<h3 id="内存耗尽怎么办？"><a href="#内存耗尽怎么办？" class="headerlink" title="内存耗尽怎么办？"></a>内存耗尽怎么办？</h3><p>如果在申请动态内存时找不到足够大的内存块，malloc和new将返回NULL指针，宣告内存申请失败。通常有三种方式处理“内存耗尽”问题。</p>
<p>（1）判断指针是否为NULL，如果是则马上用return语句终止本函数。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">void Func(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　A *a = new A;</span><br><span class="line"></span><br><span class="line">　if(a == NULL)</span><br><span class="line"></span><br><span class="line">　&#123;</span><br><span class="line"></span><br><span class="line">　　return;</span><br><span class="line"></span><br><span class="line">　&#125;</span><br><span class="line"></span><br><span class="line">　…</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（2）判断指针是否为NULL，如果是则马上用exit(1)终止整个程序的运行。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void Func(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　A *a = new A;</span><br><span class="line"></span><br><span class="line">　if(a == NULL)</span><br><span class="line"></span><br><span class="line">　&#123;</span><br><span class="line"></span><br><span class="line">　　cout &lt;&lt; “Memory Exhausted” &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">　　exit(1);</span><br><span class="line"></span><br><span class="line">　&#125;</span><br><span class="line"></span><br><span class="line">　…</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（3）为new和malloc设置异常处理函数。例如Visual C++可以用_set_new_hander函数为new设置用户自己定义的异常处理函数，也可以让malloc享用与new<br>相同的异常处理函数。详细内容请参考C++使用手册。</p>
<p>上述（1）（2）方式使用最普遍。如果一个函数内有多处需要申请动态内存，那么方式（1）就显得力不从心（释放内存很麻烦），应该用方式（2）来处理。</p>
<p>很多人不忍心用exit(1)，问：“不编写出错处理程序，让操作系统自己解决行不行？”</p>
<p>不行。如果发生“内存耗尽”这样的事情，一般说来应用程序已经无药可救。如果不用exit(1) 把坏程序杀死，它可能会害死操作系统。道理如同：如果不把歹徒击毙，<br>歹徒在老死之前会犯下更多的罪。</p>
<p>有一个很重要的现象要告诉大家。对于32位以上的应用程序而言，无论怎样使用malloc与new，几乎不可能导致“内存耗尽”。我在Windows 98下用Visual C++编写了测试程序，<br>见示例7。这个程序会无休止地运行下去，根本不会终止。因为32位操作系统支持“虚存”，内存用完了，自动用硬盘空间顶替。我只听到硬盘嘎吱嘎吱地响，Window 98已经累得<br>对键盘、鼠标毫无反应。</p>
<p>我可以得出这么一个结论：对于32位以上的应用程序，“内存耗尽”错误处理程序毫无用处。这下可把Unix和Windows程序员们乐坏了：反正错误处理程序不起作用，<br>我就不写了，省了很多麻烦。<br>我不想误导读者，必须强调：不加错误处理将导致程序的质量很差，千万不可因小失大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">void main(void)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">　float *p = NULL;</span><br><span class="line"></span><br><span class="line">　while(TRUE)</span><br><span class="line"></span><br><span class="line">　&#123;</span><br><span class="line"></span><br><span class="line">　　p = new float[1000000];</span><br><span class="line"></span><br><span class="line">　　cout &lt;&lt; “eat memory” &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">　　if(p==NULL)</span><br><span class="line"></span><br><span class="line">　　　exit(1);</span><br><span class="line"></span><br><span class="line">　&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="malloc-free的使用要点"><a href="#malloc-free的使用要点" class="headerlink" title="malloc/free的使用要点"></a>malloc/free的使用要点</h3><p>函数malloc的原型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void * malloc(size_t size);</span><br></pre></td></tr></table></figure></p>
<p>用malloc申请一块长度为length的整数类型的内存，程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int *p = (int *) malloc(sizeof(int) * length);</span><br><span class="line">我们应当把注意力集中在两个要素上：“类型转换”和“sizeof”。</span><br><span class="line"></span><br><span class="line">* malloc返回值的类型是void *，所以在调用malloc时要显式地进行类型转换，将void * 转换成所需要的指针类型。</span><br><span class="line">* malloc函数本身并不识别要申请的内存是什么类型，它只关心内存的总字节数。我们通常记不住int, float等数据类型的变量的确切字节数。</span><br><span class="line">例如int变量在16位系统下是2个字节，在32位下是4个字节；而float变量在16位系统下是4个字节，在32位下也是4个字节。最好用以下程序作一次测试：</span><br></pre></td></tr></table></figure></p>
<p>cout &lt;&lt; sizeof(char) &lt;&lt; endl;</p>
<p>cout &lt;&lt; sizeof(int) &lt;&lt; endl;</p>
<p>cout &lt;&lt; sizeof(unsigned int) &lt;&lt; endl;</p>
<p>cout &lt;&lt; sizeof(long) &lt;&lt; endl;</p>
<p>cout &lt;&lt; sizeof(unsigned long) &lt;&lt; endl;</p>
<p>cout &lt;&lt; sizeof(float) &lt;&lt; endl;</p>
<p>cout &lt;&lt; sizeof(double) &lt;&lt; endl;</p>
<p>cout &lt;&lt; sizeof(void *) &lt;&lt; endl;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在malloc的“()”中使用sizeof运算符是良好的风格，但要当心有时我们会昏了头，写出 p = malloc(sizeof(p))这样的程序来。</span><br><span class="line">函数free的原型如下：</span><br></pre></td></tr></table></figure></p>
<p>void free( void * memblock );<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">为什么free函数不象malloc函数那样复杂呢？这是因为指针p的类型以及它所指的内存的容量事先都是知道的，语句free(p)能正确地释放内存。</span><br><span class="line">如果p是NULL指针，那么free对p无论操作多少次都不会出问题。如果p不是NULL指针，那么free对p连续操作两次就会导致程序运行错误。</span><br><span class="line"></span><br><span class="line">### new/delete的使用要点</span><br><span class="line">运算符new使用起来要比函数malloc简单得多，例如：</span><br></pre></td></tr></table></figure></p>
<p>int <em>p1 = (int </em>)malloc(sizeof(int) * length);</p>
<p>int *p2 = new int[length];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是因为new内置了sizeof、类型转换和类型安全检查功能。对于非内部数据类型的对象而言，new在创建动态对象的同时完成了初始化工作。</span><br><span class="line">如果对象有多个构造函数，那么new的语句也可以有多种形式。例如</span><br></pre></td></tr></table></figure></p>
<p>class Obj</p>
<p>{</p>
<p>　public :</p>
<p>　　Obj(void); // 无参数的构造函数</p>
<p>　　Obj(int x); // 带一个参数的构造函数</p>
<p>　　…</p>
<p>}</p>
<p>void Test(void)</p>
<p>{</p>
<p>　Obj *a = new Obj;</p>
<p>　Obj *b = new Obj(1); // 初值为1</p>
<p>　…</p>
<p>　delete a;</p>
<p>　delete b;</p>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果用new创建对象数组，那么只能使用对象的无参数构造函数。例如：</span><br></pre></td></tr></table></figure></p>
<p>Obj *objects = new Obj[100]; // 创建100个动态对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">不能写成：</span><br></pre></td></tr></table></figure></p>
<p>Obj *objects = new Obj<a href="1">100</a>;// 创建100个动态对象的同时赋初值1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在用delete释放对象数组时，留意不要丢了符号‘[]’。例如</span><br></pre></td></tr></table></figure></p>
<p>delete []objects; // 正确的用法</p>
<p>delete objects; // 错误的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">后者有可能引起程序崩溃和内存泄漏。</span><br><span class="line"></span><br><span class="line">## C++中的健壮指针和资源管理</span><br><span class="line"></span><br><span class="line">我最喜欢的对资源的定义是：&quot;任何在你的程序中获得并在此后释放的东西?quot;内存是一个相当明显的资源的例子。它需要用new来获得，用delete来释放。</span><br><span class="line">同时也有许多其它类型的资源文件句柄、重要的片断、Windows中的GDI资源，等等。将资源的概念推广到程序中创建、释放的所有对象也是十分方便的，无论</span><br><span class="line">对象是在堆中分配的还是在栈中或者是在全局作用于内生命的。</span><br><span class="line"></span><br><span class="line">对于给定的资源的拥有着，是负责释放资源的一个对象或者是一段代码。所有权分立为两种级别——自动的和显式的（automatic and explicit），如果一个对象</span><br><span class="line">的释放是由语言本身的机制来保证的，这个对象的就是被自动地所有。例如，一个嵌入在其他对象中的对象，他的清除需要其他对象来在清除的时候保证。外面</span><br><span class="line">的对象被看作嵌入类的所有者。 　　</span><br><span class="line"></span><br><span class="line">类似地，每个在栈上创建的对象（作为自动变量）的释放（破坏）是在控制流离开了对象被定义的作用域的时候保证的。这种情况下，作用于被看作是对象的所有者。</span><br><span class="line">注意所有的自动所有权都是和语言的其他机制相容的，包括异常。无论是如何退出作用域的——正常流程控制退出、一个break语句、一个return、一个goto、或者是</span><br><span class="line">一个throw——自动资源都可以被清除。</span><br><span class="line"></span><br><span class="line">到目前为止，一切都很好！问题是在引入指针、句柄和抽象的时候产生的。如果通过一个指针访问一个对象的话，比如对象在堆中分配，C++不自动地关注它的释放。</span><br><span class="line">程序员必须明确的用适当的程序方法来释放这些资源。比如说，如果一个对象是通过调用new来创建的，它需要用delete来回收。一个文件是用CreateFile(Win32 API)打开的，</span><br><span class="line">它需要用CloseHandle来关闭。用EnterCritialSection进入的临界区（Critical Section）需要LeaveCriticalSection退出，等等。一个&quot;裸&quot;指针，文件句柄，或者临界区状态</span><br><span class="line">没有所有者来确保它们的最终释放。基本的资源管理的前提就是确保每个资源都有他们的所有者。</span><br><span class="line"></span><br><span class="line">### 第一条规则（RAII）</span><br><span class="line"></span><br><span class="line">一个指针，一个句柄，一个临界区状态只有在我们将它们封装入对象的时候才会拥有所有者。这就是我们的第一规则：在构造函数中分配资源，在析构函数中释放资源。</span><br><span class="line"></span><br><span class="line">当你按照规则将所有资源封装的时候，你可以保证你的程序中没有任何的资源泄露。这点在当封装对象（Encapsulating Object）在栈中建立或者嵌入在其他的对象中的时候非常明显。</span><br><span class="line">但是对那些动态申请的对象呢？不要急！任何动态申请的东西都被看作一种资源，并且要按照上面提到的方法进行封装。这一对象封装对象的链不得不在某个地方终止。它最终终止在</span><br><span class="line">最高级的所有者，自动的或者是静态的。这些分别是对离开作用域或者程序时释放资源的保证。</span><br><span class="line"></span><br><span class="line">下面是资源封装的一个经典例子。在一个多线程的应用程序中，线程之间共享对象的问题是通过用这样一个对象联系临界区来解决的。每一个需要访问共享资源的客户需要获得临界区。</span><br><span class="line">例如，这可能是Win32下临界区的实现方法。</span><br></pre></td></tr></table></figure></p>
<p>class CritSect</p>
<p>{</p>
<p>　friend class Lock;</p>
<p>　public:</p>
<p>　　CritSect () { InitializeCriticalSection (&amp;_critSection); }</p>
<p>　　~CritSect () { DeleteCriticalSection (&amp;_critSection); }</p>
<p>　private:</p>
<p>　　void Acquire ()</p>
<p>　　{</p>
<p>　　　EnterCriticalSection (&amp;_critSection);</p>
<p>　　}</p>
<p>　　void Release ()</p>
<p>　　{</p>
<p>　　　LeaveCriticalSection (&amp;_critSection);</p>
<p>　　}</p>
<p>　private:</p>
<p>　　CRITICAL_SECTION _critSection;</p>
<p>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里聪明的部分是我们确保每一个进入临界区的客户最后都可以离开。&quot;进入&quot;临界区的状态是一种资源，并应当被封装。封装器通常被称作一个锁（lock）。</span><br></pre></td></tr></table></figure></p>
<p>class Lock</p>
<p>{</p>
<p>　public:</p>
<p>　　Lock (CritSect&amp; critSect) : _critSect (critSect)</p>
<p>　　{</p>
<p>　　　_critSect.Acquire ();</p>
<p>　　}</p>
<p>　　~Lock ()</p>
<p>　　{</p>
<p>　　　_critSect.Release ();</p>
<p>　　}</p>
<p>　private</p>
<p>　　CritSect &amp; _critSect;</p>
<p>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">锁一般的用法如下：</span><br></pre></td></tr></table></figure></p>
<p>void Shared::Act () throw (char *)</p>
<p>{</p>
<p>　Lock lock (_critSect);</p>
<p>　// perform action —— may throw</p>
<p>　// automatic destructor of lock</p>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注意无论发生什么，临界区都会借助于语言的机制保证释放。</span><br><span class="line"></span><br><span class="line">还有一件需要记住的事情——每一种资源都需要被分别封装。这是因为资源分配是一个非常容易出错的操作，是要资源是有限提供的。我们会假设一个失败的资源分配会</span><br><span class="line">导致一个异常——事实上，这会经常的发生。所以如果你想试图用一个石头打两只鸟的话，或者在一个构造函数中申请两种形式的资源，你可能就会陷入麻烦。只要想想</span><br><span class="line">在一种资源分配成功但另一种失败抛出异常时会发生什么。因为构造函数还没有全部完成，析构函数不可能被调用，第一种资源就会发生泄露。</span><br><span class="line"></span><br><span class="line">这种情况可以非常简单的避免。无论何时你有一个需要两种以上资源的类时，写两个小的封装器将它们嵌入你的类中。每一个嵌入的构造都可以保证删除，即使包装类</span><br><span class="line">没有构造完成。</span><br><span class="line"></span><br><span class="line">### Smart Pointers</span><br><span class="line"></span><br><span class="line">我们至今还没有讨论最常见类型的资源——用操作符new分配，此后用指针访问的一个对象。我们需要为每个对象分别定义一个封装类吗？（事实上，C++标准模板库已经</span><br><span class="line">有了一个模板类，叫做auto_ptr，其作用就是提供这种封装。我们一会儿在回到auto_ptr。）让我们从一个极其简单、呆板但安全的东西开始。看下面的Smart Pointer</span><br><span class="line">模板类，它十分坚固，甚至无法实现。</span><br></pre></td></tr></table></figure></p>
<p>emplate <class t=""></class></p>
<p>class SmartPointer</p>
<p>{</p>
<p>　public:</p>
<p>　　~SmartPointer () { delete _p; }</p>
<p>　　T * operator-&gt;() { return _p; }</p>
<p>　　T const * operator-&gt;() const { return _p; }</p>
<p>　protected:</p>
<p>　　SmartPointer (): _p (0) {}</p>
<p>　　explicit SmartPointer (T* p): _p (p) {}</p>
<p>　　T * _p;</p>
<p>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">为什么要把SmartPointer的构造函数设计为protected呢？如果我需要遵守第一条规则，那么我就必须这样做。资源——在这里是class T的一个对象——必须在封装器的构造函数中分配。</span><br><span class="line">但是我不能只简单的调用new T，因为我不知道T的构造函数的参数。因为，在原则上，每一个T都有一个不同的构造函数；我需要为他定义个另外一个封装器。模板的用处会很大，为</span><br><span class="line">每一个新的类，我可以通过继承SmartPointer定义一个新的封装器，并且提供一个特定的构造函数。</span><br></pre></td></tr></table></figure></p>
<p>class SmartItem: public SmartPointer<item></item></p>
<p>{</p>
<p>　public:</p>
<p>　　explicit SmartItem (int i)</p>
<p>　　: SmartPointer<item> (new Item (i)) {}</item></p>
<p>};<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">为每一个类提供一个Smart Pointer真的值得吗？说实话——不！他很有教学的价值，但是一旦你学会如何遵循第一规则的话，你就可以放松规则并使用一些高级的技术。这一技术是让</span><br><span class="line">SmartPointer的构造函数成为public，但是只是是用它来做资源转换（Resource Transfer）我的意思是用new操作符的结果直接作为SmartPointer的构造函数的参数，像这样：</span><br></pre></td></tr></table></figure></p>
<p>SmartPointer<item> item (new Item (i));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这个方法明显更需要自控性，不只是你，而且包括你的程序小组的每个成员。他们都必须发誓出了作资源转换外不把构造函数用在人以其他用途。幸运的是，这条规矩很容易得以加强。</span><br><span class="line">只需要在源文件中查找所有的new即可。</span><br><span class="line"></span><br><span class="line">### Resource Transfer</span><br><span class="line"></span><br><span class="line">到目前为止，我们所讨论的一直是生命周期在一个单独的作用域内的资源。现在我们要解决一个困难的问题——如何在不同的作用域间安全的传递资源。这一问题在当你处理容器的时候会</span><br><span class="line">变得十分明显。你可以动态的创建一串对象，将它们存放至一个容器中，然后将它们取出，并且在最终安排它们。为了能够让这安全的工作——没有泄露——对象需要改变其所有者。</span><br><span class="line"></span><br><span class="line">这个问题的一个非常显而易见的解决方法是使用Smart Pointer，无论是在加入容器前还是还找到它们以后。这是他如何运作的，你加入Release方法到Smart Pointer中：</span><br></pre></td></tr></table></figure></item></p>
<p>template <class t=""></class></p>
<p>T * SmartPointer<t>::Release ()</t></p>
<p>{</p>
<p>T * pTmp = _p;</p>
<p>_p = 0;</p>
<p>return pTmp;</p>
<p>}<br><code>`</code></p>
<p>注意在Release调用以后，Smart Pointer就不再是对象的所有者了——它内部的指针指向空。现在，调用了Release都必须是一个负责的人并且迅速隐藏返回的指针到新的所有者对象中。<br>在我们的例子中，容器调用了Release，比如这个Stack的例子：</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/09/28/详解C++中指针-取地址-解引用与引用的区别/" rel="next" title="详解C++中指针()、取地址(&)、解引用()与引用(&)的区别 (完整代码)">
                <i class="fa fa-chevron-left"></i> 详解C++中指针()、取地址(&)、解引用()与引用(&)的区别 (完整代码)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.jpg"
                alt="XiaoJun" />
            
              <p class="site-author-name" itemprop="name">XiaoJun</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/xiaojun-cd" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#内存管理"><span class="nav-number">1.</span> <span class="nav-text">内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-内存管理详解"><span class="nav-number">1.1.</span> <span class="nav-text">C++内存管理详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内存分配方式"><span class="nav-number">1.1.1.</span> <span class="nav-text">内存分配方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分配方式简介"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">分配方式简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#明确区分堆与栈"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">明确区分堆与栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#堆和栈究竟有什么区别？"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">堆和栈究竟有什么区别？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制C-的内存分配"><span class="nav-number">1.1.2.</span> <span class="nav-text">控制C++的内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重载全局的new和delete操作符"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">重载全局的new和delete操作符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为单个的类重载-new-和delete"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">为单个的类重载 new[ ]和delete[ ]</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见的内存错误及其对策"><span class="nav-number">1.1.3.</span> <span class="nav-text">常见的内存错误及其对策</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针与数组的对比"><span class="nav-number">1.1.4.</span> <span class="nav-text">指针与数组的对比</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#修改内容"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">修改内容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内容复制与比较"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">内容复制与比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算内存容量"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">计算内存容量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指针参数是如何传递内存的？"><span class="nav-number">1.1.5.</span> <span class="nav-text">指针参数是如何传递内存的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#杜绝“野指针”"><span class="nav-number">1.1.6.</span> <span class="nav-text">杜绝“野指针”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有了malloc-free为什么还要new-delete？"><span class="nav-number">1.1.7.</span> <span class="nav-text">有了malloc/free为什么还要new/delete？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存耗尽怎么办？"><span class="nav-number">1.1.8.</span> <span class="nav-text">内存耗尽怎么办？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc-free的使用要点"><span class="nav-number">1.1.9.</span> <span class="nav-text">malloc/free的使用要点</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">XiaoJun</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
